# Main gateway server configuration with intelligent routing

server {
    listen 80 default_server;
    listen [::]:80 default_server;
    server_name _;

    # Connection limits
    limit_conn addr 50;

    # Add request ID header
    add_header X-Request-ID $request_id;

    # Gateway health endpoint
    location = /health {
        access_log off;
        return 200 '{"status":"healthy","service":"gateway","timestamp":"$time_iso8601"}';
        add_header Content-Type application/json;
    }

    # Gateway status and metrics (internal)
    location = /gateway/status {
        access_log off;
        allow 127.0.0.1;
        allow 10.0.0.0/8;
        allow 172.16.0.0/12;
        allow 192.168.0.0/16;
        deny all;

        stub_status on;
    }

    # API routes with authentication and rate limiting
    location /api/ {
        # Rate limiting
        limit_req zone=api burst=10 nodelay;

        # Basic auth header forwarding (JWT validation simplified for development)
        # In production, enable: access_by_lua_block { require("gateway.auth").validate_jwt() }

        # Proxy to API upstream
        proxy_pass http://api_upstream;
        include /etc/nginx/conf.d/proxy_headers.conf;

        # API-specific headers
        proxy_set_header X-Gateway-Route "api";
        proxy_set_header X-Request-Start $msec;
    }

    # Authentication routes with stricter rate limiting
    location /api/v1/auth/ {
        # Stricter rate limiting for auth endpoints
        limit_req zone=auth burst=3 nodelay;

        # No JWT validation for auth endpoints
        proxy_pass http://api_upstream;
        include /etc/nginx/conf.d/proxy_headers.conf;

        proxy_set_header X-Gateway-Route "auth";
    }

    # Storage routes with upload-specific handling
    location /storage/ {
        # Rate limiting for uploads
        limit_req zone=uploads burst=5 nodelay;

        # Optional authentication for storage access (simplified for development)
        # In production, enable: access_by_lua_block { require("gateway.auth").validate_storage_access() }

        # Proxy to storage upstream
        proxy_pass http://storage_upstream/;
        include /etc/nginx/conf.d/proxy_headers.conf;

        # Upload-specific settings
        client_max_body_size 100M;
        proxy_set_header X-Gateway-Route "storage";
    }

    # Task execution routes (future - for Stage 4)
    location /tasks/ {
        # Rate limiting for task execution
        limit_req zone=api burst=5 nodelay;

        # JWT authentication and task routing (simplified for development)
        # In production, enable:
        # access_by_lua_block { require("gateway.auth").validate_jwt() }
        # access_by_lua_block { require("gateway.task_router").route_request() }

        # Fallback to API upstream for task management
        proxy_pass http://api_upstream;
        include /etc/nginx/conf.d/proxy_headers.conf;

        proxy_set_header X-Gateway-Route "tasks";
    }

    # Frontend static assets and SPA routing
    location / {
        # Basic rate limiting for frontend
        limit_req zone=api burst=20 nodelay;

        # Proxy to frontend upstream
        proxy_pass http://frontend_upstream;
        include /etc/nginx/conf.d/proxy_headers.conf;

        # Frontend-specific headers
        proxy_set_header X-Gateway-Route "frontend";

        # Handle SPA routing
        proxy_intercept_errors on;
        error_page 404 = @frontend_fallback;
    }

    # SPA fallback for client-side routing
    location @frontend_fallback {
        proxy_pass http://frontend_upstream;
        include /etc/nginx/conf.d/proxy_headers.conf;
    }

    # Internal health check location
    location = /internal/health_check {
        internal;
        access_log off;
        proxy_pass $upstream_health_url;
    }

    # Service registry endpoint (internal) - disabled for development
    # location = /internal/service_registry {
    #     internal;
    #     access_log off;
    #     content_by_lua_block {
    #         require("gateway.service_discovery").handle_registry_request()
    #     }
    # }
}

# HTTPS server configuration (when SSL is enabled)
server {
    listen 443 ssl http2 default_server;
    listen [::]:443 ssl http2 default_server;
    server_name _;

    # SSL configuration will be included from ssl.conf

    # Redirect to main server block with SSL context
    location / {
        # Set SSL context for Lua scripts
        set $ssl_enabled 1;

        # Include all locations from HTTP server
        # This is a simplified approach - in production, duplicate the locations
        return 301 http://$host$request_uri;
    }
}
