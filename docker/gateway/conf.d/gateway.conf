# Main gateway server configuration with intelligent routing

server {
    listen 80 default_server;
    listen [::]:80 default_server;
    server_name _;

    # Connection limits
    limit_conn addr 50;

    # Security headers for all responses
    add_header X-Frame-Options DENY always;
    add_header X-Content-Type-Options nosniff always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header X-Permitted-Cross-Domain-Policies none always;
    add_header X-Download-Options noopen always;

    # Content Security Policy - Updated for 3Dmol.js molecular viewer support
    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://3dmol.org; style-src 'self' 'unsafe-inline' https://at.alicdn.com; img-src 'self' data: https:; font-src 'self' data: https://at.alicdn.com; connect-src 'self' ws: wss:; media-src 'self'; object-src 'none'; frame-src 'none'; base-uri 'self'; form-action 'self';" always;

    # Add request ID header
    add_header X-Request-ID $request_id;

    # Gateway health endpoint
    location = /health {
        access_log off;
        return 200 '{"status":"healthy","service":"gateway","timestamp":"$time_iso8601"}';
        add_header Content-Type application/json;
    }

    # Gateway status and metrics (internal)
    location = /gateway/status {
        access_log off;
        allow 127.0.0.1;
        allow 10.0.0.0/8;
        allow 172.16.0.0/12;
        allow 192.168.0.0/16;
        deny all;

        stub_status on;
    }

    # API routes with authentication and rate limiting
    location /api/ {
        # Rate limiting
        limit_req zone=api burst=10 nodelay;

        # Basic auth header forwarding (JWT validation simplified for development)
        # In production, enable: access_by_lua_block { require("gateway.auth").validate_jwt() }

        # Proxy to API upstream
        proxy_pass http://api_upstream;
        include /etc/nginx/conf.d/proxy_headers.conf;

        # API-specific headers
        proxy_set_header X-Gateway-Route "api";
        proxy_set_header X-Request-Start $msec;
    }

    # FastAPI documentation endpoints
    location /docs {
        # No rate limiting for docs in development
        proxy_pass http://api_upstream/docs;
        include /etc/nginx/conf.d/proxy_headers.conf;
        proxy_set_header X-Gateway-Route "docs";
    }

    location /redoc {
        # Alternative API documentation
        proxy_pass http://api_upstream/redoc;
        include /etc/nginx/conf.d/proxy_headers.conf;
        proxy_set_header X-Gateway-Route "docs";
    }

    location /openapi.json {
        # OpenAPI specification
        proxy_pass http://api_upstream/openapi.json;
        include /etc/nginx/conf.d/proxy_headers.conf;
        proxy_set_header X-Gateway-Route "docs";
        add_header Content-Type application/json;
    }

    # Authentication routes with stricter rate limiting
    location /api/v1/auth/ {
        # Stricter rate limiting for auth endpoints
        limit_req zone=auth burst=3 nodelay;

        # No JWT validation for auth endpoints
        proxy_pass http://api_upstream;
        include /etc/nginx/conf.d/proxy_headers.conf;

        proxy_set_header X-Gateway-Route "auth";
    }

    # Storage routes with upload-specific handling
    location /storage/ {
        # Rate limiting for uploads
        limit_req zone=uploads burst=5 nodelay;

        # Optional authentication for storage access (simplified for development)
        # In production, enable: access_by_lua_block { require("gateway.auth").validate_storage_access() }

        # Proxy to storage upstream
        proxy_pass http://storage_upstream/;
        include /etc/nginx/conf.d/proxy_headers.conf;

        # Upload-specific settings
        client_max_body_size 100M;
        proxy_set_header X-Gateway-Route "storage";
    }

    # Task execution routes (future - for Stage 4)
    location /tasks/ {
        # Rate limiting for task execution
        limit_req zone=api burst=5 nodelay;

        # JWT authentication and task routing (simplified for development)
        # In production, enable:
        # access_by_lua_block { require("gateway.auth").validate_jwt() }
        # access_by_lua_block { require("gateway.task_router").route_request() }

        # Fallback to API upstream for task management
        proxy_pass http://api_upstream;
        include /etc/nginx/conf.d/proxy_headers.conf;

        proxy_set_header X-Gateway-Route "tasks";
    }

    # Frontend static assets and SPA routing
    location / {
        # Basic rate limiting for frontend
        limit_req zone=api burst=20 nodelay;

        # Proxy to frontend upstream
        proxy_pass http://frontend_upstream;
        include /etc/nginx/conf.d/proxy_headers.conf;

        # Frontend-specific headers
        proxy_set_header X-Gateway-Route "frontend";

        # Handle SPA routing
        proxy_intercept_errors on;
        error_page 404 = @frontend_fallback;
    }

    # SPA fallback for client-side routing
    location @frontend_fallback {
        proxy_pass http://frontend_upstream;
        include /etc/nginx/conf.d/proxy_headers.conf;
    }

    # Internal health check location
    location = /internal/health_check {
        internal;
        access_log off;
        proxy_pass http://health_check_upstream;
    }

    # Service registry endpoint (internal) - disabled for development
    # location = /internal/service_registry {
    #     internal;
    #     access_log off;
    #     content_by_lua_block {
    #         require("gateway.service_discovery").handle_registry_request()
    #     }
    # }

    # Security location blocks
    # Rate limiting error responses
    location = /429.json {
        internal;
        return 429 '{"error":"Rate limit exceeded","message":"Too many requests"}';
        add_header Content-Type application/json;
    }

    # Security error responses
    location = /403.json {
        internal;
        return 403 '{"error":"Forbidden","message":"Access denied"}';
        add_header Content-Type application/json;
    }

    location = /401.json {
        internal;
        return 401 '{"error":"Unauthorized","message":"Authentication required"}';
        add_header Content-Type application/json;
    }

    # Block common attack patterns
    location ~* \.(php|asp|aspx|jsp|cgi)$ {
        return 404;
    }

    # Block access to sensitive files
    location ~* \.(git|svn|hg|bzr|cvs)/ {
        deny all;
    }

    location ~* \.(env|config|ini|log|bak|backup|old|tmp)$ {
        deny all;
    }
}

# HTTPS server configuration (when SSL is enabled) - DISABLED for development
# server {
#     listen 443 ssl http2 default_server;
#     listen [::]:443 ssl http2 default_server;
#     server_name _;
#
#     # SSL configuration will be included from ssl.conf
#
#     # Redirect to main server block with SSL context
#     location / {
#         # Set SSL context for Lua scripts
#         set $ssl_enabled 1;
#
#         # Include all locations from HTTP server
#         # This is a simplified approach - in production, duplicate the locations
#         return 301 http://$host$request_uri;
#     }
# }
